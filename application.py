import os, requests, re

from bs4 import BeautifulSoup
from datetime import date
from cs50 import SQL
from flask import Flask, flash, redirect, render_template, request, session
from flask_session import Session
from tempfile import mkdtemp
from werkzeug.exceptions import default_exceptions, HTTPException, InternalServerError
from werkzeug.security import check_password_hash, generate_password_hash

from helpers import apology, login_required, lookup


# Configure application
app = Flask(__name__)

# Ensure templates are auto-reloaded
app.config["TEMPLATES_AUTO_RELOAD"] = True


# Ensure responses aren't cached
@app.after_request
def after_request(response):
    response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
    response.headers["Expires"] = 0
    response.headers["Pragma"] = "no-cache"
    return response


# Configure session to use filesystem (instead of signed cookies)
app.config["SESSION_FILE_DIR"] = mkdtemp()
app.config["SESSION_PERMANENT"] = False
app.config["SESSION_TYPE"] = "filesystem"
Session(app)

# Configure CS50 Library to use SQLite database
db = SQL("sqlite:///huds.db")

# Boolean to track whether plan has already been generated by the user for the day
planExists = False

# Web scrapes page associated with an individual food item on the HUDs menu to get the name, nutrition facts, and entree info
def scrape_item(URL_list):
    # Instantiates BeautifulSoup object to webscrape relevant table
    page = requests.get(URL_list[0])
    soup = BeautifulSoup(page.content, 'html.parser')
    item_name = soup.find(class_="sub_title").get_text()

    # Scrape for allergens
    allergens = soup.find(class_="labelallergensvalue")
    if allergens is not None:
        allergens = allergens.get_text()
        allergens = allergens.split(", ")

    # Scrape for calories and all nutrients
    facts = soup.find(class_="facts")
    nutrientNames = ["fat", "saturated fat", "cholesterol", "sodium", "carbs", "dietary fiber", "calories", "fat", "sugars", "protein", "sodium", "vitamin a", "vitamin c", "iron", "calcium", "cholesterol"]
    nutrientDict = {}
    if facts is not None:
        nutrients = soup.find_all(class_="last")[1].get_text()
        nutrients = nutrients.split("%")
        for pos in range(len(nutrients) - 1):
            escapes = ''.join([chr(char) for char in range(1, 32)])
            translator = str.maketrans('', '', escapes)
            temp = nutrients[pos].translate(translator)
            nutrientDict[nutrientNames[pos]] = temp
        nutrientDict["fat"] = round(75 * int(nutrientDict["fat"]) / 100.0)
        nutrientDict["carbs"] = round(322.5 * int(nutrientDict["carbs"]) / 100.0)
        nutrientDict["protein"] = round(53.33 * int(nutrientDict["protein"]) / 100.0)
        nutrientDict["calories"] = round(2000 * int(nutrientDict["calories"]) / 100.0)

        # Return all relevant information about specific food item in a dictionary, given information is present on site; otherwise return None
        if nutrientDict['calories'] > 0:
            return {"name": item_name.strip(), "is_entree": URL_list[1], "is_vegetarian": URL_list[2], "is_vegan": URL_list[3], "allergens": allergens, "nutrients": nutrientDict}
        else:
            return None
    else:
        return None

    # return None

# Web scrape a particular meal of the day from given url
def scrape_meal(url, meal):
    # Download webpage and instantiate BeautifulSoup object
    URL_complete = url + str(meal)
    html_text = requests.get(URL_complete)
    soup = BeautifulSoup(html_text.text, "html.parser")

    # Scrape from all td tags inside class="category" in tbody tag and store in list URL_list
    table = soup.find_all('table')[2]
    table_rows = table.find_all('tr')
    is_entree = False
    URL_list = []
    for row in table_rows:
        # Determine if items about to be scraped are entrees or not
        if (row.has_attr("class")):
            category_title = row.find('td').get_text()
            if "Entree" in category_title:
                is_entree = 1
            else:
                is_entree = 0
        else:
            is_vegetarian = 0
            is_vegan = 0
            items = row.find_all('a', href=True)
            images = row.find_all('img', alt=True)

            # Determine if food item is flagged as Vegetarian or Vegan
            if images is not None:
                for image in images:
                    if image['alt'] == "Vegetarian":
                        is_vegetarian = 1
                    if image['alt'] == "Vegan":
                        is_vegan = 1

            # Keep track of food item's relevant URL to be scraped, as well as entree and vegetarian/vegan statuses
            for item in items:
                URL_list.append([item['href'], is_entree, is_vegetarian, is_vegan])

    # Get the current day of the week
    day_of_week = date.today().weekday()

    # Iterate over URL_list to web scrape for each menu item, and add info to foods database
    for elem in URL_list:
        info = scrape_item(elem)
        if info is not None:
            tableElement = db.execute("SELECT * FROM foods WHERE name = ?", info['name'])
            nutrients = info['nutrients']

            # If the current day is not Sunday
            if day_of_week is not 6:
                # Set menu item's meal options, and either insert into or update table depending on whether food entry is already present in foods table to prevent duplicates
                if meal == 0:
                    if len(tableElement) == 1:
                        db.execute("UPDATE foods SET is_breakfast = 1 WHERE name = ?", info['name'])
                    else:
                        db.execute("INSERT INTO foods (name, calories, is_entree, is_breakfast, is_vegetarian, is_vegan, fat, saturated_fat, cholesterol, sodium, carbs, dietary_fiber, sugars, protein, calcium, vitamin_A, vitamin_C, iron) VALUES (?, ?, ?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", info['name'], nutrients['calories'], info['is_entree'], info['is_vegetarian'], info['is_vegan'], nutrients['fat'], nutrients['saturated fat'], nutrients['cholesterol'], nutrients['sodium'], nutrients['carbs'], nutrients['dietary fiber'], nutrients['sugars'], nutrients['protein'], nutrients['calcium'], nutrients['vitamin a'], nutrients['vitamin c'], nutrients['iron'])
                elif meal == 1:
                    if len(tableElement) == 1:
                        db.execute("UPDATE foods SET is_lunch = 1 WHERE name = ?", info['name'])
                    else:
                        db.execute("INSERT INTO foods (name, calories, is_entree, is_lunch, is_vegetarian, is_vegan, fat, saturated_fat, cholesterol, sodium, carbs, dietary_fiber, sugars, protein, calcium, vitamin_A, vitamin_C, iron) VALUES (?, ?, ?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", info['name'], nutrients['calories'], info['is_entree'], info['is_vegetarian'], info['is_vegan'], nutrients['fat'], nutrients['saturated fat'], nutrients['cholesterol'], nutrients['sodium'], nutrients['carbs'], nutrients['dietary fiber'], nutrients['sugars'], nutrients['protein'], nutrients['calcium'], nutrients['vitamin a'], nutrients['vitamin c'], nutrients['iron'])
                else:
                    if len(tableElement) == 1:
                        db.execute("UPDATE foods SET is_dinner = 1 WHERE name = ?", info['name'])
                    else:
                        db.execute("INSERT INTO foods (name, calories, is_entree, is_dinner, is_vegetarian, is_vegan, fat, saturated_fat, cholesterol, sodium, carbs, dietary_fiber, sugars, protein, calcium, vitamin_A, vitamin_C, iron) VALUES (?, ?, ?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", info['name'], nutrients['calories'], info['is_entree'], info['is_vegetarian'], info['is_vegan'], nutrients['fat'], nutrients['saturated fat'], nutrients['cholesterol'], nutrients['sodium'], nutrients['carbs'], nutrients['dietary fiber'], nutrients['sugars'], nutrients['protein'], nutrients['calcium'], nutrients['vitamin a'], nutrients['vitamin c'], nutrients['iron'])
            else:

                # If the current day is Sunday, in which case there are only two meals, namely lunch and dinner at meal = 0 and 1, respectively
                if meal == 0:
                    if len(tableElement) == 1:
                        db.execute("UPDATE foods SET is_lunch = 1 WHERE name = ?", info['name'])
                    else:
                        db.execute("INSERT INTO foods (name, calories, is_entree, is_lunch, is_vegetarian, is_vegan, fat, saturated_fat, cholesterol, sodium, carbs, dietary_fiber, sugars, protein, calcium, vitamin_A, vitamin_C, iron) VALUES (?, ?, ?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", info['name'], nutrients['calories'], info['is_entree'], info['is_vegetarian'], info['is_vegan'], nutrients['fat'], nutrients['saturated fat'], nutrients['cholesterol'], nutrients['sodium'], nutrients['carbs'], nutrients['dietary fiber'], nutrients['sugars'], nutrients['protein'], nutrients['calcium'], nutrients['vitamin a'], nutrients['vitamin c'], nutrients['iron'])
                else:
                    if len(tableElement) == 1:
                        db.execute("UPDATE foods SET is_dinner = 1 WHERE name = ?", info['name'])
                    else:
                        db.execute("INSERT INTO foods (name, calories, is_entree, is_dinner, is_vegetarian, is_vegan, fat, saturated_fat, cholesterol, sodium, carbs, dietary_fiber, sugars, protein, calcium, vitamin_A, vitamin_C, iron) VALUES (?, ?, ?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", info['name'], nutrients['calories'], info['is_entree'], info['is_vegetarian'], info['is_vegan'], nutrients['fat'], nutrients['saturated fat'], nutrients['cholesterol'], nutrients['sodium'], nutrients['carbs'], nutrients['dietary fiber'], nutrients['sugars'], nutrients['protein'], nutrients['calcium'], nutrients['vitamin a'], nutrients['vitamin c'], nutrients['iron'])

            # Insert food's associated allergens into the food_allergens table in the database; also handling duplicates
            foodId = db.execute("SELECT id FROM foods WHERE name = ?", info['name'])[0]['id']
            has_allergens = False
            if info['allergens'] != ['']:
                has_allergens = True
                for allergen in info['allergens']:
                    allergenId = db.execute("SELECT id FROM allergens WHERE name = ?", allergen)[0]['id']
                    tableElement = db.execute("SELECT * FROM food_allergens WHERE food_id = ? AND allergen_id = ?", foodId, allergenId)
                    if len(tableElement) < 1:
                        db.execute("INSERT INTO food_allergens (food_id, allergen_id) VALUES (?, ?)", foodId, allergenId)
            if not info['is_vegetarian']:
                has_allergens = True
                tableElement = db.execute("SELECT * FROM food_allergens WHERE food_id = ? AND allergen_id = ?", foodId, 13)
                if len(tableElement) < 1:
                    db.execute("INSERT INTO food_allergens (food_id, allergen_id) VALUES (?, ?)", foodId, 13)
            if not info['is_vegan']:
                has_allergens = True
                tableElement = db.execute("SELECT * FROM food_allergens WHERE food_id = ? AND allergen_id = ?", foodId, 12)
                if len(tableElement) < 1:
                    db.execute("INSERT INTO food_allergens (food_id, allergen_id) VALUES (?, ?)", foodId, 12)

            if not has_allergens:
                tableElement = db.execute("SELECT * FROM food_allergens WHERE food_id = ? AND allergen_id = 12", foodId)
                if len(tableElement) < 1:
                    db.execute("INSERT INTO food_allergens (food_id, allergen_id) VALUES (?, 12)", foodId)


# Calculate nutritional index for each food item as a linear combination of the frequency of each nutrient and its weight given its rarity on a given day
def balanced_nutrition_index(nutrient_weights, food):
    index_val = 0
    for nutrient in nutrient_weights:
        key = list(nutrient.keys())[0]
        indiv_amount = food[key]
        weight = nutrient[key]
        index_val += (indiv_amount * weight)
    if food['calories'] != 0:
        return round(index_val / food['calories'], 2)
    return 0


# Calculate the weights for each nutrient on a given day, depending on the frequency of that nutrient throughout the entire daily menu
def calculate_nutrient_weights(foods):
    total_nut = 0
    nutrient_totals = [{"saturated_fat": 0}, {"cholesterol": 0}, {"sodium": 0}, {"dietary_fiber": 0}, {"sugars": 0}, {"calcium": 0}, {"vitamin_A": 0}, {"vitamin_C": 0}, {"iron":0}]
    for food in foods:
        for nutrient in nutrient_totals:
            key = list(nutrient.keys())[0]
            nutrient[key] += food[key]
            total_nut += food[key]

    # Taking the complement of the frequency, as the nutrients with the least presence each day should be prioritized the most to keep a balanced diet
    for nutrient in nutrient_totals:
        key = list(nutrient.keys())[0]
        nutrient[key] = 1 - (nutrient[key] / total_nut)

    # Updating the foods table by recording the associated index for each food
    for food in foods:
        index = balanced_nutrition_index(nutrient_totals, food)
        db.execute("UPDATE foods SET BN_index = ? WHERE id = ?", index, food["id"])


# Perform daily web scraping of HUDs menu
def scrape_day():
    # Get current date in format according to URL template
    URL_stem = "http://www.foodpro.huds.harvard.edu/foodpro/menu_items.asp?date="
    URL_date = date.today().strftime("%m-%d-%Y")
    URL_stem2 = "&type=14&meal="
    URL_full_stem = URL_stem + URL_date + URL_stem2

    # Scrape first two meals of the day
    scrape_meal(URL_full_stem, 0)
    scrape_meal(URL_full_stem, 1)

    # Get the current day of the week
    day_of_week = date.today().weekday()

    # Scrape third meal of the day, as long as the day isn't Sunday
    if day_of_week is not 6:
        scrape_meal(URL_full_stem, 2)

    # Calculate the nutrient weights and balanced nutrition index for each food after web scraping
    foods = db.execute("SELECT * FROM foods")
    calculate_nutrient_weights(foods)


# Determine the foods that are part of a certain meal for the day, considering caloric intake, balanced nutrition index, healthiest entree, etc.
def create_meal(foods, max_caloric_intake, plan_list, current_calories_filled):
    food_list = plan_list
    current_caloric_intake = plan_list[0]["calories"]

    while True:
        mealAdded = False
        for current_index in range(len(foods)):
            if (max_caloric_intake - current_caloric_intake) >= foods[current_index]["calories"] and foods[current_index]['name'] != plan_list[0]['name'] and foods[current_index]['calories'] != "0":
                mealAdded = True
                food_list.append(foods[current_index])
                current_caloric_intake += foods[current_index]["calories"]
        if not mealAdded:
            break
    return food_list


# Determine the foods that are part of a meal plan for the day, making calls to create_meal for each meal
def create_plan(is_sunday, caloric_intake):
    # Partition calories for each meal
    if not is_sunday:
        breakfast_factor, lunch_factor, dinner_factor = 0.2, 0.4, 0.4
    else:
        breakfast_factor, lunch_factor, dinner_factor = 0, 0.5, 0.5

    overall_plan = []
    # Filter out foods that user is allergic to, partitioned by meal, and excluding breakfast when the day is Sunday
    if not is_sunday:
        # Breakfast
        breakfast_entrees = db.execute("SELECT DISTINCT * FROM foods WHERE is_breakfast = 1 AND is_entree = 1 AND id IN (SELECT DISTINCT food_id FROM food_allergens WHERE allergen_id NOT IN (SELECT allergen_id FROM user_allergens WHERE user_id = ?) AND food_id NOT IN (SELECT DISTINCT food_id FROM food_allergens WHERE allergen_id IN (SELECT allergen_id FROM user_allergens WHERE user_id = ?))) ORDER BY BN_index DESC", session['user_id'], session['user_id'])
        breakfast_all = db.execute("SELECT DISTINCT * FROM foods WHERE is_breakfast = 1 AND id IN (SELECT DISTINCT food_id FROM food_allergens WHERE allergen_id NOT IN (SELECT allergen_id FROM user_allergens WHERE user_id = ?) AND food_id NOT IN (SELECT DISTINCT food_id FROM food_allergens WHERE allergen_id IN (SELECT allergen_id FROM user_allergens WHERE user_id = ?))) ORDER BY BN_index DESC", session['user_id'], session['user_id'])
        breakfast_plan = []
        if len(breakfast_all) > 0:
            if len(breakfast_entrees) > 0:
                first_item = [breakfast_entrees[0]]
            else:
                first_item = [breakfast_all[0]]
            breakfast_plan = create_meal(breakfast_all, breakfast_factor * caloric_intake, first_item, 0)
        overall_plan.append(breakfast_plan)

    # Lunch
    lunch_entrees = db.execute("SELECT DISTINCT * FROM foods WHERE is_lunch = 1 AND is_entree = 1 AND id IN (SELECT DISTINCT food_id FROM food_allergens WHERE allergen_id NOT IN (SELECT allergen_id FROM user_allergens WHERE user_id = ?) AND food_id NOT IN (SELECT DISTINCT food_id FROM food_allergens WHERE allergen_id IN (SELECT allergen_id FROM user_allergens WHERE user_id = ?))) ORDER BY BN_index DESC", session['user_id'], session['user_id'])
    lunch_all = db.execute("SELECT DISTINCT * FROM foods WHERE is_lunch = 1 AND id IN (SELECT DISTINCT food_id FROM food_allergens WHERE allergen_id NOT IN (SELECT allergen_id FROM user_allergens WHERE user_id = ?) AND food_id NOT IN (SELECT DISTINCT food_id FROM food_allergens WHERE allergen_id IN (SELECT allergen_id FROM user_allergens WHERE user_id = ?))) ORDER BY BN_index DESC", session['user_id'], session['user_id'])
    for item in lunch_all:
            print("Lunch: " + str(item['name']))
    lunch_plan = []
    if len(lunch_all) > 0:
            if len(lunch_entrees) > 0:
                first_item = [lunch_entrees[0]]
            else:
                first_item = [lunch_all[0]]
            lunch_plan = create_meal(lunch_all, lunch_factor * caloric_intake, first_item, 0)
    overall_plan.append(lunch_plan)

    # Dinner
    dinner_entrees = db.execute("SELECT DISTINCT * FROM foods WHERE is_dinner = 1 AND is_entree = 1 AND id IN (SELECT DISTINCT food_id FROM food_allergens WHERE allergen_id NOT IN (SELECT allergen_id FROM user_allergens WHERE user_id = ?) AND food_id NOT IN (SELECT DISTINCT food_id FROM food_allergens WHERE allergen_id IN (SELECT allergen_id FROM user_allergens WHERE user_id = ?))) ORDER BY BN_index DESC", session['user_id'], session['user_id'])
    dinner_all = db.execute("SELECT DISTINCT * FROM foods WHERE is_dinner = 1 AND id IN (SELECT DISTINCT food_id FROM food_allergens WHERE allergen_id NOT IN (SELECT allergen_id FROM user_allergens WHERE user_id = ?) AND food_id NOT IN (SELECT DISTINCT food_id FROM food_allergens WHERE allergen_id IN (SELECT allergen_id FROM user_allergens WHERE user_id = ?))) ORDER BY BN_index DESC", session['user_id'], session['user_id'])
    dinner_plan = []
    if len(dinner_all) > 0:
            if len(dinner_entrees) > 0:
                first_item = [dinner_entrees[0]]
            else:
                first_item = [dinner_all[0]]
            dinner_plan = create_meal(dinner_all, dinner_factor * caloric_intake, first_item, 0)
    overall_plan.append(dinner_plan)

    # Combine all foods in the daily plan into one dictionary, and determine aggregate values for nutrients and calories
    if is_sunday:
        whole_plan = lunch_plan + dinner_plan
    else:
        whole_plan = breakfast_plan + lunch_plan + dinner_plan
    nutrient_counters = [{"calories": 0}, {"protein": 0}, {"carbs": 0}, {"fat": 0}, {"saturated_fat": 0}, {"cholesterol": 0}, {"sodium": 0}, {"dietary_fiber": 0}, {"sugars": 0}, {"calcium": 0}, {"vitamin_A": 0}, {"vitamin_C": 0}, {"iron":0}]
    for food in whole_plan:
        for nutrient in nutrient_counters:
            key = list(nutrient.keys())[0]
            nutrient[key] += food[key]
    total_values = []
    for nutrient in nutrient_counters:
        current_key = str(list(nutrient.keys())[0])
        if current_key != "calories" and current_key != "protein" and current_key != "carbs" and current_key != "fat":
            new_percentage = round((list(nutrient.values())[0] * 2000) / caloric_intake)
            total_values.append(new_percentage)
        else:
            total_values.append(round(list(nutrient.values())[0]))
    overall_plan.append(total_values)
    return overall_plan


@app.route("/", methods=["GET"])
@login_required
def index():
    # scrape_day()
    user_calories = db.execute("SELECT calories FROM default_settings WHERE user_id = ?", session["user_id"])[0]["calories"]
    # On sunday HUDS only serves 2 meals rather than 3
    is_sunday = (date.today().weekday() == 6)
    plan = create_plan(is_sunday, user_calories)

    # Get user's value of planExists to know whether the plan for the user has or hasn't been generated during the day yet
    planExists = db.execute("SELECT plan_exists FROM default_settings WHERE user_id = ?", session["user_id"])[0]["plan_exists"]
    if request.method == "GET":
        if planExists == 1:
            # plan = db.execute("")
            # plan = []
            name = db.execute("SELECT username FROM users WHERE id = ?", session["user_id"])[0]
            return render_template("plan.html", plan=plan, user=name)
        else:
            # Plan does not exist yet
            db.execute("UPDATE default_settings SET plan_exists = 1 WHERE user_id = ?", session["user_id"])
            return redirect("/")


@app.route("/profile-init", methods=["GET", "POST"])
def profile_init():
    """Lets user initialize profile after registering, as by changing daily caloric intake, and any allergies/dietary restrictions"""
    if request.method == "GET":
        # Get user's username and list of all allergens to display to webpage
        allergens = db.execute("SELECT name FROM allergens")
        username = db.execute("SELECT username FROM users WHERE id = ?", session["user_id"])[0]
        return render_template("profileInit.html", allergens=allergens, username=username)
    else:
        # Read in values inputed in form for caloric intake and user's allergies selected from checkboxes to store in database
        calories = request.form.get("calories")
        db.execute("INSERT INTO default_settings (user_id, calories, plan_exists, wants_default) VALUES (?, ?, 0, 0)", session["user_id"], calories)
        allergens = db.execute("SELECT name FROM allergens")
        for allergen in allergens:
            checked = request.form.get(allergen['name'])
            if checked is not None:
                restriction_id = db.execute("SELECT id FROM allergens WHERE name = ?", allergen['name'])[0]['id']
                db.execute("INSERT INTO user_allergens (user_id, allergen_id) VALUES (?, ?)", session["user_id"], restriction_id)
        return redirect("/")

@app.route("/profile-edit", methods=["GET", "POST"])
@login_required
def profile_edit():
    """Lets user edit profile, as by changing daily caloric intake, and any allergies/dietary restrictions"""
    if request.method == "GET":
        # Get user's caloric intake and selected allergens
        calories = db.execute("SELECT calories FROM default_settings WHERE user_id=?", session["user_id"])[0]
        user_allergens = db.execute("SELECT allergens.name FROM allergens JOIN user_allergens ON allergens.id = user_allergens.allergen_id WHERE user_allergens.user_id = ?", session['user_id'])
        all_allergens = db.execute("SELECT name FROM allergens")
        allergen_states = []

        # Pre-selecting allergens already marked by user on webpage for nicer user interface, so keeping track of which were selected in the allergen_states list of dictionaries
        for allergen in all_allergens:
            if allergen in user_allergens:
                allergen_states.append({'name': allergen['name'], 'state': 1})
            else:
                allergen_states.append({'name': allergen['name'], 'state': 0})
        return render_template("changeInputs.html", calories=calories, allergen_states=allergen_states, profile_edit=True)
    else:
        # Update caloric intake and allergens for users in database
        calories = request.form.get("calories")
        if calories != '':
            db.execute("UPDATE default_settings SET calories = ? WHERE user_id = ?", calories, session["user_id"])
        db.execute("DELETE FROM user_allergens WHERE user_id = ?", session["user_id"])
        allergens = db.execute("SELECT name FROM allergens")
        for allergen in allergens:
            checked = request.form.get(allergen['name'])
            if checked is not None:
                restriction_id = db.execute("SELECT id FROM allergens WHERE name = ?", allergen['name'])[0]['id']
                db.execute("INSERT INTO user_allergens (user_id, allergen_id) VALUES (?, ?)", session["user_id"], restriction_id)
        return redirect("/")


@app.route("/login", methods=["GET", "POST"])
def login():
    """Log user in"""

    # Forget any user_id
    session.clear()

    # User reached route via POST (as by submitting a form via POST)
    if request.method == "POST":

        # Ensure username was submitted
        if not request.form.get("username"):
            return apology("must provide username", 403)

        # Ensure password was submitted
        elif not request.form.get("password"):
            return apology("must provide password", 403)

        # Query database for username
        rows = db.execute("SELECT * FROM users WHERE username = ?", request.form.get("username"))

        # Ensure username exists and password is correct
        if len(rows) != 1 or not check_password_hash(rows[0]["hash"], request.form.get("password")):
            return apology("invalid username and/or password", 403)

        # Remember which user has logged in
        session["user_id"] = rows[0]["id"]

        # Redirect user to home page
        return redirect("/")

    # User reached route via GET (as by clicking a link or via redirect)
    else:
        return render_template("login.html")


@app.route("/logout")
def logout():
    """Log user out"""

    # Forget any user_id
    session.clear()

    # Redirect user to login form
    return redirect("/")


@app.route("/register", methods=["GET", "POST"])
def register():
    """Register user"""
    # When requested via GET, should display registration form
    if request.method == "GET":
        return render_template("register.html")
    # When form is submitted via POST, insert the new user into users table
    # Be sure to check for invalid inputs and to hash the user's password
    elif request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")
        confirmation = request.form.get("confirmation")
        # Ensure username was submitted
        if not username:
            return apology("Must provide username", 400)
        # Ensure password was submitted
        elif not password:
            return apology("Must provide password", 400)
        elif not password == confirmation:
            return apology("Passwords must match", 400)

        duplicate = db.execute("SELECT username FROM users WHERE username=:username", username=username)
        if len(duplicate) > 0:
            return apology("Username already exists", 400)
        hashVal = generate_password_hash(password)
        db.execute("INSERT INTO users (username, hash) VALUES (:username, :hash)", username=username, hash=hashVal)
        session["user_id"] = db.execute("SELECT id FROM users WHERE username = ?", username)[0]['id']
        return redirect("/profile-init")


def errorhandler(e):
    """Handle error"""
    if not isinstance(e, HTTPException):
        e = InternalServerError()
    return apology(e.name, e.code)


# Listen for errors
for code in default_exceptions:
    app.errorhandler(code)(errorhandler)